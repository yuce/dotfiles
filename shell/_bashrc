# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

function gitprompt()
{
    stat=`git status 2>/dev/null | head -1`
    if [ "$stat" != "" ]
    then
        #printf "%*s" $COLUMNS "(${stat:10})"
        echo " (${stat:10})"
    fi
}

# Map Ctrl-S to sth usefull other than XOFF (interrupt data flow).
stty -ixon

# ... and ignore same sucessive entries.
export HISTCONTROL=ignoreboth

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
shopt -s histappend

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"
# E=$(printf "\e")
PS1='\[\033[01;31m\]\w\[\033[00m\]$(gitprompt)\n\[\033[00;32m\]\u@\h\[\033[00m\]|\[\033[01;34m\]\t\[\033[00m\]|\[\033[36m\]\!\[\033[00m\]\$ '

#export PS1='\[$(tput setaf 3;gitprompt;tput setaf 1)\w\n\]$'

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ "$TERM" != "dumb" ]; then
    if [ `uname -s` == "Linux" ]; then
        eval "`dircolors -b`"
        alias ls='ls --color=auto'
    else
        alias ls='ls -G'
    fi
fi

if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi

export GOROOT=$HOME/go
export GOPATH=$HOME/go_path
export NODEPATH=$HOME/node
export JAVA_HOME=$HOME/jdk
export YARN_HOME=$HOME/yarn

export PATH=$PATH:$HOME/bin:/$HOME/otp/bin:/opt/elixir/bin:$NODEPATH/bin:$GOROOT/bin:$JAVA_HOME/bin:$HOME/.cargo/bin:$HOME/.cache/rebar3/bin:$YARN_HOME/bin
export EDITOR=/usr/bin/vim
export LC_ALL=en_US.UTF-8

alias ..="cd .."
alias ...='cd ../..'

alias a..="acd .."
alias a...='acd ../..'
# git related
alias g.s='git status -s'
alias g.d='git diff'
alias g+='git add'
alias g-='git reset HEAD'
alias g..='acd $(git rev-parse --show-cdup)'
alias g.m='git commit -m'
alias g.o='git checkout'
alias g.ob='git checkout -b'
alias g.p='git pam'
alias g^='git push'
alias gv='git pull'

# ramdisk
alias mount_ramdisk='sudo mount -t tmpfs -o size=1024M ramdisk $HOME/ramdisk'
alias umount_ramdisk='sudo umount $HOME/ramdisk'

alias https='http --default-scheme=https'
alias ll='ls -lh'
#alias open='xdg-open > /dev/null 2>&1'

alias pomodoro='gone -e "i3-nagbar -m Pomodoro_DONE -t warning"'

export PIP_DOWNLOAD_CACHE=$HOME/.pip_download_cache
export AUTOSRC_FILENAME=.change-this-in-your-private-settings
export AUTOSRC_MCD=1

echo
. $HOME/bin/z.sh

if [ -f $HOME/.bashrc_private ]
then
    source $HOME/.bashrc_private
fi

mcd()
{
    test -e "$1" || mkdir -p "$1"
    cd "$1"
}

hist () {
    local C=$(history | cut -c8- | fzf) && $C
}

autosrc_cd () {
    if [ "$1" == "" ]; then
        local cdto="$HOME"
    else
        local cdto="$1"
    fi
    if [ "$(type -t autosrc_exit)" == "function" ]
    then
        autosrc_exit "$cdto"
        unset -f autosrc_exit
    fi
    local autorun_path="$cdto/$AUTOSRC_FILENAME"
    if [ -f $autorun_path ]
    then
        . $autorun_path
    fi
    if [ "$AUTOSRC_MCD" == "1" ]; then
        if [ ! -e "$cdto" ];  then
            mkdir -p "$cdto"
        fi
    fi
    builtin cd "$cdto"
    if [ "$(type -t autosrc_enter)" == "function" ]
    then
        autosrc_enter
        unset -f autosrc_enter
    fi
}

autosrc_touch () {
    touch $AUTOSRC_FILENAME
    echo $AUTOSRC_FILENAME
}

alias acd=autosrc_cd

__BOOKMARKS_DIR=$HOME/.bookmarks
__read_bookmarks () {
    if [ "$1" != "" ]
    then
        local bookmark_path="$__BOOKMARKS_DIR/$1"
    else
        return 0
    fi
    if [ -f $bookmark_path ]
    then
        cat $bookmark_path
    else
        return 1
    fi
}

bookmark_mark () {
    if [ ! -d $__BOOKMARKS_DIR ]
    then
        mkdir -p $__BOOKMARKS_DIR
    fi
    if [ "$1" != "" ]
    then
        local bookmark_path="$__BOOKMARKS_DIR/$1"
    else
        local bookmark_path="$__BOOKMARKS_DIR/DEFAULT"
    fi
    local path=$(pwd)
    if [ -f $bookmark_path ]
    then
        printf "\n$path" >> $bookmark_path
    else
        printf "$path" > $bookmark_path
    fi
}

bookmark_jump () {
    local bookmarks=$(__read_bookmarks $1)
    if [ "$bookmarks" == "" ]; then
        if [ -e "$__BOOKMARKS_DIR" ]; then
            local bname="$(ls $__BOOKMARKS_DIR | fzf)"
            if [ "$bname" != "" ]; then
                bookmarks=$(__read_bookmarks $bname)
            fi
        fi
    fi
    local bookmark_count=$(echo "$bookmarks" | wc -l)
    if [ $bookmark_count -lt 2 ]; then
        local bookmark="$bookmarks"
    else
        local bookmark=$(echo "$bookmarks" | fzf)
    fi
    if [ "$bookmark" != "" ]; then
        acd "$bookmark"
    fi
}

alias m=bookmark_mark
alias j=bookmark_jump

fortune | cowsay

